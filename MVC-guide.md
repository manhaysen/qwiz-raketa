# Гайд по MVC

- [Что означает MVC?](#что-означает-mvc)
- [Делаем приложение "Бургерная" на MVC](#делаем-приложение-бургерная-на-mvc)
  - [Модель данных](#модель-данных)
  - [Представление](#представление)
  - [Контроллер](#контроллер)
  - [Связываем всё вместе и запускаем](#связываем-всё-вместе-и-запускаем)
- [Ещё раз, как это работает?](#ещё-раз-как-это-работает)

Для того чтобы код нашего приложения было легко читать и поддерживать, а также для того чтобы минимизировать количество ошибок мы применяем различные архитектурные паттерны. Один из самых известных - MVC (Model View Controller). В этом гайде мы расскажем тебе, что представляет из себя этот паттерн и покажем его реализацию на примере простого приложения.

## Что означает MVC?

![Иллюстрация паттерна MVC](readme-assets/MVC-Process.png)

Паттерн MVC используется, чтобы отделить логику и данные приложения от его визуального представления. Есть много реализаций этого паттерна, мы расскажем тебе об одной из них. Вот за что ответчает каждая из частей MVC:

**Model** - Модель данных. Отвечает за `хранение, получение и изменение данных`, а также за бизнес-логику (логику работы с данными). Модель может обращаться к базе данных или отправлять запросы на сервер. Модель не имеет доступа ни к представлению (View) ни к контроллеру.

**View** - Визуальное представление приложения. Отвечает за `отображение приложения на экране пользователя`, а также за `считывание пользовательского ввода` (ввод текста в поле формы или командную строку, клик мышкой по кнопке, и т.д.). Представление строится на основе модели, а также обновляет отображение на экране (перерендеривается) если в модели происходят изменения. Представление не может напрямую изменять модель, этим занимается контроллер.

**Controller** - Контроллер вызывает методы представления исходя из того какой экран (какую страницу) необходимо показать пользователю в данный момент. Когда пользователь совершает какое-то действие (ввод с клавиатуры, клик мышкой и т.д.) `контроллер решает какой метод модели следует вызывать, чтобы данные приложения изменились`.

Это была сухая теория. Теперь, чтобы стало понятнее перейдём к практике.

## Делаем приложение "Бургерная" на MVC

Нам нужно сделать простое консольное приложение, которое позволит создавать бургеры с разными начинками. Когда пользователь запускает приложение он должен увидеть приглашение к тому чтобы сделать первый бургер:

![Экран приветствия](readme-assets/example-1.png)

После того как пользователь нажимает любую клавишу он попадает на страницу создания бургера.

![Создание бургера](readme-assets/example-2.png)

Здесь он может вводить новые ингридиенты, чтобы добавить их в бургер.

![Добавление ингридиентов](readme-assets/example-3.png)

Процесс продолжается пока пользователь не нажмёт Enter при пустой строке ввода. Затем он перемещается на начальный экран где видит все созданные ранее бургеры.

![Список всех бургеров](readme-assets/example-4.png)

Пример готового приложения смотри в папке `burgers-example`.

### Модель данных

Удобнее всего в начале реализовать модель данных приложения. Давай подумаем на основе каких данных будет отображаться наше приложение? А также какие экраны/страницы будут в твоём приложении? Все данные будут приватными полями класса Model. Напомним, что приватное поле начинается с # и к нему можно обратиться только из методов класса, в котором оно определено. Также объявим методы, которые позволят изменять модель.

```javascript
// Model.js

class Model {
  // Страница, на которой в данный момент находится пользователь:
  // 'burgers' - стартовая страница, на которой отображаются все созданные бургеры
  // 'make-burger' - страница создания нового бургера
  #page = 'burgers';

  // Массив уже созданных бургеров. Каждый бургер в свою очередь будет представлять
  // из себя массив ингридиентов. То есть #burgers - это массив массивов.
  #burgers = [];

  // Бургер, который мы создаём в данный момент. Массив строк-ингридиентов.
  #currentBurger;

  // #page, #burgers, #currentBurger - приватные поля. Чтобы обращаться к ним из
  // других классов сделаем методы-геттеры.

  getPage() {
    return this.#page;
  }

  getCurrentBurger() {
    return this.#currentBurger;
  }

  getBurgers() {
    return this.#burgers;
  }

  // Перейти на страницу создания бургера
  startMakeBurger() {
    this.#page = 'make-burger';
    this.#currentBurger = [];
  }

  // Добавить новый ингридиент к текущему бургеру
  addIngridient(indgridient) {
    this.#currentBurger.push(indgridient);
  }

  // Закончить создание бургера и перейти на стартовую страницу
  stopMakeBurger() {
    // если в бургере есть хоть один ингридиент, то добавляем его в список готовых бургеров
    if (this.#currentBurger.length) {
      this.#burgers.push(this.#currentBurger);
      this.#currentBurger = undefined;
    }

    // переходим обратно на стартовую страницу
    this.#page = 'burgers';
  }
}

module.exports = Model;
```

### Представление

Теперь возьмёмся за представление. Мы уже определились, что у нас будет две страницы: страница со списком бургеров и страница создания бургера. Теперь добавим во View соответствующие методы.

```javascript
// View.js

const readlineSync = require('readline-sync');

class View {
  // Отобразить стартовую страницу
  renderBurgersPage(burgers) {
    console.log();

    // Если ранее были созданы бургеры, отображаем их
    if (burgers.length) {
      console.log('Бургеры:');
      burgers.forEach(this.#renderBurger);
      console.log();
    }

    readlineSync.question('Нажмите любую клавишу, чтобы сделать бургер…');
  }

  // Отобразить страницу создания бургера
  renderMakeBurgerPage(currentBurger) {
    console.log();

    // Отображаем текущий бургер
    this.#renderBurger(currentBurger);
    console.log();

    console.log('Введите название нового ингридиента или оставьте пустым, чтобы закончить');
    // считываем следующий ингридиент из командной строки и возвращаем его контроллеру
    const ingridient = readlineSync.question('> ');
    return ingridient;
  }

  // Рендерим на экране бургер
  #renderBurger(burger) {
    console.log(`[${burger.join(' | ')}]`);
  }
}

module.exports = View;
```

Обрати внимание на очень важный момент. После того как View считывает пользовательский ввод (в данном случае из командной строки) он сразу возвращает управление контроллеру.

### Контроллер

Первая задача контроллера узнать у модели на какой странице находится пользователь и попросить View отрендерить эту страницу. Сделаем это в методе `run` контроллера. Обрати внимание, View нужны данные, чтобы рендерить страницы. Мы будем брать эти данные из модели и передавать их в методы View в качестве аргументов.

```javascript
// View.js

class Controller {
  #model;

  #view;

  constructor(model, view) {
    this.#model = model;
    this.#view = view;
  }

  // Контроллер - главный класс, с его метода run начинается работа нашего приложения
  run() {
    // отображаем ту страницу, на которой сейчас находится пользователь
    switch (this.#model.getPage()) {
      case 'burgers': {
        this.#view.renderBurgersPage(this.#model.getBurgers());
        return;
      }

      case 'make-burger': {
        this.#view.renderMakeBurgerPage(this.#model.getCurrentBurger());
        return;
      }

      default:
        throw new Error('Wrong page');
    }
  }
}

module.exports = Controller;
```

После того как представление отрендерило страницу и дождалось пользовательского ввода контроллер получает то что ввёл пользователь и передаёт эти данные в модель. Для этого контроллер вызывает соответствующий метод модели. А затем контроллер вызывает свой же метод `run`, чтобы перерендерить приложение на основе уже изменившихся данных.

```javascript
// Controller.js

class Controller {
  #model;

  #view;

  constructor(model, view) {
    this.#model = model;
    this.#view = view;
  }

  // Контроллер - главный класс, с его метода run начинается работа нашего приложения
  run() {
    // отображаем ту страницу, на которой сейчас находится пользователь
    switch (this.#model.getPage()) {
      case 'burgers': {
        this.#view.renderBurgersPage(this.#model.getBurgers());
        this.#model.startMakeBurger();
        return this.run();
      }

      case 'make-burger': {
        const ingridient = this.#view.renderMakeBurgerPage(this.#model.getCurrentBurger());
        if (ingridient) {
          this.#model.addIngridient(ingridient);
        } else {
          this.#model.stopMakeBurger();
        }
        return this.run();
      }

      default:
        throw new Error('Wrong page');
    }
  }
}

module.exports = Controller;
```

### Связываем всё вместе и запускаем

```javascript
// runner.js

const Controller = require('./Controller');
const Model = require('./Model');
const View = require('./View');

const model = new Model();
const view = new View();
const controller = new Controller(model, view);

controller.run();
```

## Ещё раз, как это работает?

Наше приложение готово. Давай проследим как оно работает:

1. Сначала мы вызываем метод `run` контроллера.
2. Контроллер получает из модели текущую страницу приложения (это 'burgers') и вызывает метод `renderBurgersPage` представления, чтобы отрисовать её.
3. Метод `renderBurgersPage` отображает на экране приглашение создать новый бургер и ждёт пока пользователь нажмёт на любую клавишу. Метод завершает работу и управление переходит обратно к контроллеру.
4. Контроллер вызывает метод `startMakeBurger` модели.
5. Метод `startMakeBurger` меняет страницу на 'make-burger' и создаёт новый массив `#currentBurger` для нового бургера. Метод завершает работу и управление переходит обратно к контроллеру.
6. Контроллер опять запускает свой метод `run`, чтобы отрендерить уже новую страницу ('make-burger').
7. И т.д. (остальную логику работы приложения разбери самостоятельно).

Обрати внимание, MVC в этой реализации всегда "ходит" по одному и тому же кругу:

1. Метод `run` контроллера спрашивает текущую страницу
2. Затем он вызывает соответствующий метод представления
3. Представление отображает текущую страницу и ждёт пользовательского ввода
4. Затем представление возвращает пользовательский ввод контроллеру
5. Контроллер передаёт эти данные в модель
6. Модель меняет свои данные
7. Контроллер опять вызывает метод `run` и всё повторяется
